from __future__ import annotations

import numpy as np
# Define the original 3D coordinate arrays
# S1xyz contains coordinate data organized in rows and columns
n = 11
m = 16
S1xyz = np.array([
    [[0.000308, 0.315, 1.41453], [0.273107, 0.1575, 1.41453], [0.545904, 0.315, 1.41453], 
     [0.818702, 0.1575, 1.41453], [1.0915, 0.315, 1.41453], [1.3643, 0.1575, 1.41453], 
     [1.6371, 0.315, 1.41453], [1.90989, 0.1575, 1.41453], [2.18269, 0.315, 1.41453], 
     [2.45549, 0.1575, 1.41453], [2.72829, 0.315, 1.41453], [3.00109, 0.1575, 1.41453], 
     [3.27389, 0.315, 1.41453], [3.54668, 0.1575, 1.41453], [3.81948, 0.315, 1.41453], 
     [4.09228, 0.1575, 1.41453]],
    
    [[0.000068, 0.315, 1.45759], [0.271113, 0.1575, 1.45598], [0.542451, 0.315, 1.4514], 
     [0.814287, 0.1575, 1.44455], [1.08676, 0.315, 1.43644], [1.35991, 0.1575, 1.42831], 
     [1.63368, 0.315, 1.42139], [1.90792, 0.1575, 1.41677], [2.18239, 0.315, 1.41515], 
     [2.45683, 0.1575, 1.41678], [2.73096, 0.315, 1.42142], [3.00458, 0.1575, 1.42833], 
     [3.27755, 0.315, 1.43646], [3.54984, 0.1575, 1.44457], [3.82151, 0.315, 1.45142], 
     [4.09275, 0.1575, 1.45598]],
    
    [[-0.0001764, 0.315, 1.49261], [0.268972, 0.1575, 1.48943], [0.538705, 0.315, 1.48036], 
     [0.809459, 0.1575, 1.46673], [1.08149, 0.315, 1.45054], [1.35487, 0.1575, 1.43426], 
     [1.62949, 0.315, 1.42039], [1.90502, 0.1575, 1.4111], [2.18103, 0.315, 1.40785], 
     [2.45694, 0.1575, 1.41115], [2.73226, 0.315, 1.42047], [3.00655, 0.1575, 1.43433], 
     [3.27957, 0.315, 1.45058], [3.55124, 0.1575, 1.46674], [3.82168, 0.315, 1.48036], 
     [4.09122, 0.1575, 1.48943]],
    
    [[-0.0004171, 0.315, 1.53539], [0.266711, 0.1575, 1.53069], [0.534726, 0.315, 1.5172], 
     [0.804267, 0.1575, 1.49686], [1.07572, 0.315, 1.47264], [1.34919, 0.1575, 1.4482], 
     [1.62449, 0.315, 1.42733], [1.90119, 0.1575, 1.41333], [2.17859, 0.315, 1.40843], 
     [2.45588, 0.1575, 1.41342], [2.73223, 0.315, 1.42748], [3.00705, 0.1575, 1.44833], 
     [3.27997, 0.315, 1.4727], [3.55089, 0.1575, 1.49686], [3.81997, 0.315, 1.51717], 
     [4.08768, 0.1575, 1.53066]],
    
    [[-0.0006367, 0.315, 1.57846], [0.265394, 0.1575, 1.57209], [0.531956, 0.315, 1.55399], 
     [0.799682, 0.1575, 1.52684], [1.06942, 0.315, 1.49463], [1.3419, 0.1575, 1.4621], 
     [1.6174, 0.315, 1.43418], [1.89551, 0.1575, 1.41533], [2.17509, 0.315, 1.40873], 
     [2.45451, 0.1575, 1.41547], [2.73222, 0.315, 1.43437], [3.0071, 0.1575, 1.46229], 
     [3.27881, 0.315, 1.49477], [3.5478, 0.1575, 1.52691], [3.81493, 0.315, 1.55402], 
     [4.08112, 0.1575, 1.57211]],
    
    [[-0.0008813, 0.315, 1.62103], [0.263419, 0.1575, 1.61313], [0.528222, 0.315, 1.59056], 
     [0.794243, 0.1575, 1.55676], [1.06254, 0.315, 1.51668], [1.33426, 0.1575, 1.47609], 
     [1.60998, 0.315, 1.44115], [1.88925, 0.1575, 1.41751], [2.17058, 0.315, 1.40922], 
     [2.4517, 0.1575, 1.41772], [2.73045, 0.315, 1.44145], [3.0054, 0.1575, 1.47634], 
     [3.27617, 0.315, 1.5168], [3.54354, 0.1575, 1.55678], [3.80879, 0.315, 1.59053], 
     [4.07311, 0.1575, 1.61308]],
    
    [[-0.0011095, 0.315, 1.66331], [0.261396, 0.1575, 1.65387], [0.524375, 0.315, 1.62692], 
     [0.788543, 0.1575, 1.58659], [1.05526, 0.315, 1.53872], [1.32605, 0.1575, 1.49015], 
     [1.60181, 0.315, 1.44817], [1.88211, 0.1575, 1.41969], [2.16505, 0.315, 1.40972], 
     [2.44777, 0.1575, 1.42], [2.72745, 0.315, 1.44859], [3.00228, 0.1575, 1.49047], 
     [3.27195, 0.315, 1.53883], [3.53754, 0.1575, 1.58652], [3.80079, 0.315, 1.62678], 
     [4.06317, 0.1575, 1.65376]],
    
    [[-0.0013715, 0.315, 1.70529], [0.25932, 0.1575, 1.69436], [0.52045, 0.315, 1.66312], 
     [0.782719, 0.1575, 1.61627], [1.04767, 0.315, 1.56063], [1.31722, 0.1575, 1.50414], 
     [1.59273, 0.315, 1.45521], [1.87394, 0.1575, 1.4219], [2.15856, 0.315, 1.4102], 
     [2.44289, 0.1575, 1.42228], [2.72334, 0.315, 1.45576], [2.99776, 0.1575, 1.50455], 
     [3.26606, 0.315, 1.56076], [3.52976, 0.1575, 1.61614], [3.79096, 0.315, 1.66288], 
     [4.05132, 0.1575, 1.69421]],
    
    [[-0.0016186, 0.315, 1.74686], [0.257249, 0.1575, 1.7345], [0.516502, 0.315, 1.69904], 
     [0.776762, 0.1575, 1.64578], [1.03968, 0.315, 1.58248], [1.30766, 0.1575, 1.51814], 
     [1.58269, 0.315, 1.46226], [1.86476, 0.1575, 1.42406], [2.15111, 0.315, 1.41062], 
     [2.43711, 0.1575, 1.42453], [2.71823, 0.315, 1.4629], [2.992, 0.1575, 1.51861], 
     [3.25863, 0.315, 1.58263], [3.52021, 0.1575, 1.64562], [3.77923, 0.315, 1.69871], 
     [4.03756, 0.1575, 1.73426]],
    
    [[-0.0018697, 0.315, 1.78802], [0.255202, 0.1575, 1.77421], [0.512514, 0.315, 1.73457], 
     [0.770565, 0.1575, 1.67505], [1.0312, 0.315, 1.60426], [1.29741, 0.1575, 1.53216], 
     [1.57181, 0.315, 1.46931], [1.85466, 0.1575, 1.42615], [2.14274, 0.315, 1.41095], 
     [2.4304, 0.1575, 1.42674], [2.71213, 0.315, 1.47007], [2.9851, 0.1575, 1.53267], 
     [3.24983, 0.315, 1.60438], [3.50903, 0.1575, 1.67483], [3.7657, 0.315, 1.73417], 
     [4.02194, 0.1575, 1.77391]],
    
    [[-0.0021325, 0.315, 1.82868], [0.253148, 0.1575, 1.81342], [0.50848, 0.315, 1.76965], 
     [0.764185, 0.1575, 1.70396], [1.02235, 0.315, 1.62584], [1.28662, 0.1575, 1.54615], 
     [1.56029, 0.315, 1.47639], [1.84381, 0.1575, 1.42827], [2.1335, 0.315, 1.41129], 
     [2.42271, 0.1575, 1.42899], [2.70498, 0.315, 1.4773], [2.97706, 0.1575, 1.54673], 
     [3.23972, 0.315, 1.62594], [3.49633, 0.1575, 1.70367], [3.75051, 0.315, 1.76916], 
     [4.00458, 0.1575, 1.81308]]
])

# S2xyz contains another set of coordinate data
S2xyz = np.array([
    [[0.0003078, 0.315, 1.71547], [0.273107, 0.1575, 1.71547], [0.545903, 0.315, 1.71547], 
     [0.818701, 0.1575, 1.71547], [1.0915, 0.315, 1.71547], [1.3643, 0.1575, 1.71547], 
     [1.6371, 0.315, 1.71547], [1.90989, 0.1575, 1.71547], [2.18269, 0.315, 1.71547], 
     [2.45549, 0.1575, 1.71547], [2.72829, 0.315, 1.71547], [3.00109, 0.1575, 1.71547], 
     [3.27389, 0.315, 1.71547], [3.54668, 0.1575, 1.71547], [3.81948, 0.315, 1.71547], 
     [4.09228, 0.1575, 1.71547]],
    
    [[0.0005483, 0.315, 1.75855], [0.274984, 0.1575, 1.75691], [0.549111, 0.315, 1.75228], 
     [0.822728, 0.1575, 1.74536], [1.0957, 0.315, 1.73724], [1.36799, 0.1575, 1.72913], 
     [1.63967, 0.315, 1.72228], [1.9109, 0.1575, 1.71771], [2.18191, 0.315, 1.71611], 
     [2.45296, 0.1575, 1.71772], [2.7243, 0.315, 1.72229], [2.99613, 0.1575, 1.72914], 
     [3.26861, 0.315, 1.73726], [3.54176, 0.1575, 1.74539], [3.81553, 0.315, 1.75231], 
     [4.08977, 0.1575, 1.75693]],
    
    [[0.0007919, 0.315, 1.79363], [0.27671, 0.1575, 1.79033], [0.552026, 0.315, 1.78101], 
     [0.826319, 0.1575, 1.76714], [1.09934, 0.315, 1.75089], [1.37101, 0.1575, 1.73474], 
     [1.64145, 0.315, 1.72112], [1.91098, 0.1575, 1.71205], [2.18006, 0.315, 1.70887], 
     [2.44921, 0.1575, 1.71204], [2.71894, 0.315, 1.72111], [2.98969, 0.1575, 1.73475], 
     [3.26172, 0.315, 1.75093], [3.53511, 0.1575, 1.76722], [3.80972, 0.315, 1.78109], 
     [4.08526, 0.1575, 1.79038]],
    
    [[0.0010407, 0.315, 1.83648], [0.278321, 0.1575, 1.83149], [0.554676, 0.315, 1.81744], 
     [0.829497, 0.1575, 1.79659], [1.10242, 0.315, 1.77221], [1.37334, 0.1575, 1.74806], 
     [1.64242, 0.315, 1.72775], [1.91013, 0.1575, 1.71426], [2.17714, 0.315, 1.70952], 
     [2.44426, 0.1575, 1.71423], [2.71228, 0.315, 1.72771], [2.98182, 0.1575, 1.74806], 
     [3.25327, 0.315, 1.77227], [3.52674, 0.1575, 1.79672], [3.80204, 0.315, 1.81759], 
     [4.07874, 0.1575, 1.83159]],
    
    [[0.0012621, 0.315, 1.87942], [0.280685, 0.1575, 1.87268], [0.558392, 0.315, 1.85379], 
     [0.833282, 0.1575, 1.82587], [1.10499, 0.315, 1.79339], [1.37397, 0.1575, 1.76125], 
     [1.64111, 0.315, 1.73415], [1.9073, 0.1575, 1.71604], [2.17319, 0.315, 1.70969], 
     [2.43922, 0.1575, 1.71606], [2.70578, 0.315, 1.73417], [2.97351, 0.1575, 1.76133], 
     [3.24325, 0.315, 1.79353], [3.51571, 0.1575, 1.82606], [3.79123, 0.315, 1.85399], 
     [4.06934, 0.1575, 1.87282]],
    
    [[0.0015, 0.315, 1.92193], [0.282633, 0.1575, 1.91345], [0.561399, 0.315, 1.88971], 
     [0.836327, 0.1575, 1.85481], [1.10711, 0.315, 1.81436], [1.37447, 0.1575, 1.77437], 
     [1.63973, 0.315, 1.74064], [1.90405, 0.1575, 1.71807], [2.16818, 0.315, 1.71012], 
     [2.43248, 0.1575, 1.71805], [2.6973, 0.315, 1.7406], [2.9633, 0.1575, 1.77439], 
     [3.23161, 0.315, 1.81448], [3.50332, 0.1575, 1.85506], [3.77904, 0.315, 1.89002], 
     [4.05832, 0.1575, 1.91365]],
    
    [[0.0017541, 0.315, 1.96414], [0.284481, 0.1575, 1.95386], [0.564146, 0.315, 1.92525], 
     [0.838976, 0.1575, 1.8834], [1.10866, 0.315, 1.83504], [1.37426, 0.1575, 1.78733], 
     [1.6375, 0.315, 1.74704], [1.89987, 0.1575, 1.72007], [2.16218, 0.315, 1.71055], 
     [2.4247, 0.1575, 1.71998], [2.68767, 0.315, 1.74692], [2.95183, 0.1575, 1.78727], 
     [3.21856, 0.315, 1.83515], [3.48936, 0.1575, 1.88371], [3.76511, 0.315, 1.92566], 
     [4.0454, 0.1575, 1.95414]],
    
    [[0.0020236, 0.315, 2.00598], [0.286352, 0.1575, 1.99388], [0.566797, 0.315, 1.96041], 
     [0.841227, 0.1575, 1.91162], [1.10952, 0.315, 1.8554], [1.37322, 0.1575, 1.80002], 
     [1.63441, 0.315, 1.75328], [1.89478, 0.1575, 1.72198], [2.15518, 0.315, 1.71089], 
     [2.41586, 0.1575, 1.7218], [2.67699, 0.315, 1.75305], [2.93926, 0.1575, 1.7999], 
     [3.20421, 0.315, 1.85553], [3.47376, 0.1575, 1.91202], [3.74926, 0.315, 1.96095], 
     [4.03047, 0.1575, 1.99428]],
    
    [[0.0022649, 0.315, 2.04745], [0.288264, 0.1575, 2.03354], [0.56939, 0.315, 1.99516], 
     [0.843158, 0.1575, 1.93945], [1.10979, 0.315, 1.87544], [1.37137, 0.1575, 1.81245], 
     [1.63039, 0.315, 1.75935], [1.88871, 0.1575, 1.7238], [2.14723, 0.315, 1.71121], 
     [2.40609, 0.1575, 1.72356], [2.66535, 0.315, 1.75903], [2.9256, 0.1575, 1.81228], 
     [3.18852, 0.315, 1.87559], [3.45651, 0.1575, 1.93993], [3.73154, 0.315, 1.9958], 
     [4.01359, 0.1575, 2.03401]],
    
    [[0.0025066, 0.315, 2.08855], [0.29017, 0.1575, 2.07276], [0.571903, 0.315, 2.02943], 
     [0.844868, 0.1575, 1.96682], [1.1096, 0.315, 1.89511], [1.3688, 0.1575, 1.82466], 
     [1.62548, 0.315, 1.76532], [1.88171, 0.1575, 1.72558], [2.13836, 0.315, 1.71148], 
     [2.39543, 0.1575, 1.72529], [2.65275, 0.315, 1.76493], [2.9108, 0.1575, 1.82445], 
     [3.17143, 0.315, 1.89523], [3.43764, 0.1575, 1.96733], [3.71204, 0.315, 2.03018], 
     [3.99488, 0.1575, 2.07334]],
    
    [[0.0027684, 0.315, 2.12912], [0.291967, 0.1575, 2.1114], [0.574237, 0.315, 2.06308], 
     [0.846315, 0.1575, 1.99365], [1.10897, 0.315, 1.91444], [1.36558, 0.1575, 1.83674], 
     [1.61976, 0.315, 1.77127], [1.87385, 0.1575, 1.72735], [2.12863, 0.315, 1.71173], 
     [2.38389, 0.1575, 1.72697], [2.63923, 0.315, 1.77074], [2.89493, 0.1575, 1.83642], 
     [3.1531, 0.315, 1.91454], [3.41735, 0.1575, 1.99424], [3.69102, 0.315, 2.06404], 
     [3.97455, 0.1575, 2.11216]]
])
import numpy as np

# Define the Moxyz data as a 3D numpy array
Moxyz = np.array([
    [[0.181254, 0.315, 1.565], [0.45405, 0.1575, 1.565], [0.726847, 0.315, 1.565],
     [0.999647, 0.1575, 1.565], [1.27245, 0.315, 1.565], [1.54524, 0.1575, 1.565],
     [1.81804, 0.315, 1.565], [2.09084, 0.1575, 1.565], [2.36364, 0.315, 1.565],
     [2.63643, 0.1575, 1.565], [2.90923, 0.315, 1.565], [3.18203, 0.1575, 1.565],
     [3.45483, 0.315, 1.565], [3.72763, 0.1575, 1.565], [4.00042, 0.315, 1.565],
     [4.27322, 0.1575, 1.565]],

    [[0.181219, 0.315, 1.60744], [0.453955, 0.1575, 1.60376], [0.726683, 0.315, 1.59753],
     [0.999407, 0.1575, 1.58966], [1.27212, 0.315, 1.58137], [1.54484, 0.1575, 1.57391],
     [1.81757, 0.315, 1.56841], [2.09032, 0.1575, 1.56574], [2.36306, 0.315, 1.56627],
     [2.6358, 0.1575, 1.56993], [2.90853, 0.315, 1.57617], [3.18125, 0.1575, 1.58403],
     [3.45397, 0.315, 1.59233], [3.72669, 0.1575, 1.59979], [3.99942, 0.315, 1.60528],
     [4.27216, 0.1575, 1.60797]],

    [[0.181102, 0.315, 1.64185], [0.453643, 0.1575, 1.63452], [0.726166, 0.315, 1.62205],
     [0.998681, 0.1575, 1.60635], [1.27119, 0.315, 1.58979], [1.5437, 0.1575, 1.57488],
     [1.81623, 0.315, 1.56393], [2.08878, 0.1575, 1.55856], [2.36134, 0.315, 1.55963],
     [2.63388, 0.1575, 1.56695], [2.9064, 0.315, 1.57942], [3.17891, 0.1575, 1.59513],
     [3.45142, 0.315, 1.61169], [3.72393, 0.1575, 1.62659], [3.99646, 0.315, 1.63755],
     [4.26902, 0.1575, 1.64291]],

    [[0.180902, 0.315, 1.68404], [0.45312, 0.1575, 1.67306], [0.725299, 0.315, 1.65439],
     [0.997454, 0.1575, 1.63085], [1.2696, 0.315, 1.60604], [1.54177, 0.1575, 1.58372],
     [1.81397, 0.315, 1.5673], [2.08621, 0.1575, 1.55928], [2.35846, 0.315, 1.56088],
     [2.63067, 0.1575, 1.57185], [2.90285, 0.315, 1.59053], [3.17501, 0.1575, 1.61406],
     [3.44716, 0.315, 1.63887], [3.71932, 0.1575, 1.6612], [3.99152, 0.315, 1.67761],
     [4.26376, 0.1575, 1.68564]],

    [[0.181233, 0.315, 1.72636], [0.453637, 0.1575, 1.71165], [0.725247, 0.315, 1.68668],
     [0.996135, 0.1575, 1.65529], [1.26679, 0.315, 1.62227], [1.53783, 0.1575, 1.59251],
     [1.80966, 0.315, 1.57049], [2.08224, 0.1575, 1.55967], [2.35506, 0.315, 1.56179],
     [2.62746, 0.1575, 1.57651], [2.89907, 0.315, 1.60149], [3.16996, 0.1575, 1.63287],
     [3.44061, 0.315, 1.66588], [3.71165, 0.1575, 1.69566], [3.98349, 0.315, 1.71766],
     [4.25607, 0.1575, 1.72848]],

    [[0.18126, 0.315, 1.76826], [0.453473, 0.1575, 1.74981], [0.724399, 0.315, 1.71859],
     [0.994173, 0.1575, 1.67952], [1.26358, 0.315, 1.63838], [1.53364, 0.1575, 1.60127],
     [1.80496, 0.315, 1.57377], [2.07746, 0.1575, 1.56023], [2.35033, 0.315, 1.56292],
     [2.62254, 0.1575, 1.58136], [2.89346, 0.315, 1.61255], [3.16323, 0.1575, 1.65165],
     [3.43265, 0.315, 1.69277], [3.7027, 0.1575, 1.7299], [3.97402, 0.315, 1.7574],
     [4.24652, 0.1575, 1.77092]],

    [[0.181233, 0.315, 1.80984], [0.453149, 0.1575, 1.78766], [0.723247, 0.315, 1.75029],
     [0.991724, 0.1575, 1.70358], [1.25972, 0.315, 1.65444], [1.52863, 0.1575, 1.61002],
     [1.79934, 0.315, 1.57703], [2.07167, 0.1575, 1.56079], [2.34453, 0.315, 1.56402],
     [2.61644, 0.1575, 1.58617], [2.88654, 0.315, 1.62357], [3.15502, 0.1575, 1.6703],
     [3.42302, 0.315, 1.71942], [3.69193, 0.1575, 1.76381], [3.96263, 0.315, 1.79679],
     [4.23497, 0.1575, 1.81306]],

    [[0.18119, 0.315, 1.85109], [0.452771, 0.1575, 1.82523], [0.721909, 0.315, 1.78172],
     [0.98887, 0.1575, 1.72742], [1.2552, 0.315, 1.67036], [1.52278, 0.1575, 1.61871],
     [1.79275, 0.315, 1.58027], [2.06491, 0.1575, 1.56129], [2.33773, 0.315, 1.56507],
     [2.60931, 0.1575, 1.59093], [2.87845, 0.315, 1.63446], [3.14541, 0.1575, 1.68874],
     [3.41174, 0.315, 1.7458], [3.67932, 0.1575, 1.79745], [3.94929, 0.315, 1.83592],
     [4.22145, 0.1575, 1.85489]],

    [[0.181178, 0.315, 1.892], [0.452399, 0.1575, 1.86246], [0.720472, 0.315, 1.81284],
     [0.985709, 0.1575, 1.75106], [1.2501, 0.315, 1.68615], [1.5161, 0.1575, 1.62732],
     [1.78523, 0.315, 1.58344], [2.05719, 0.1575, 1.56176], [2.33002, 0.315, 1.56607],
     [2.60124, 0.1575, 1.59561], [2.86931, 0.315, 1.64522], [3.13455, 0.1575, 1.707],
     [3.39894, 0.315, 1.77192], [3.66494, 0.1575, 1.83075], [3.93407, 0.315, 1.87462],
     [4.20603, 0.1575, 1.89631]],

    [[0.181186, 0.315, 1.93248], [0.452016, 0.1575, 1.89924], [0.718887, 0.315, 1.84358],
     [0.9822, 0.1575, 1.77442], [1.24442, 0.315, 1.70177], [1.50864, 0.1575, 1.63586],
     [1.7768, 0.315, 1.58657], [2.04854, 0.1575, 1.56215], [2.32142, 0.315, 1.56702],
     [2.59225, 0.1575, 1.60027], [2.85912, 0.315, 1.65592], [3.12243, 0.1575, 1.72507],
     [3.38465, 0.315, 1.79772], [3.64887, 0.1575, 1.86364], [3.91702, 0.315, 1.91291],
     [4.18877, 0.1575, 1.93734]],

    [[0.181139, 0.315, 1.97241], [0.451527, 0.1575, 1.93547], [0.717077, 0.315, 1.87383],
     [0.978255, 0.1575, 1.79745], [1.23811, 0.315, 1.71727], [1.50043, 0.1575, 1.64438],
     [1.76754, 0.315, 1.58972], [2.03903, 0.1575, 1.56256], [2.31188, 0.315, 1.56797],
     [2.58227, 0.1575, 1.60492], [2.84782, 0.315, 1.66654], [3.109, 0.1575, 1.74292],
     [3.36885, 0.315, 1.82312], [3.63117, 0.1575, 1.89603], [3.89827, 0.315, 1.95072],
     [4.16977, 0.1575, 1.97786]]
])

# Copy Moxyz to create S1xyz and S2xyz (assuming they are initially the same)
#S1xyz = Moxyz.copy()
#S2xyz = Moxyz.copy()

# Define constants
dy = 0.315 - 0.1575

# Reference z-values for normalization
reference_z = np.array([1.565, 1.5869, 1.6008, 1.6225, 1.6441, 1.6656, 1.687,
                        1.7081, 1.7291, 1.7498, 1.7703])

# Adjust the z-values in all datasets
for i in range(n):
    for j in range(m):
        S1xyz[i, j, 2] -= reference_z[i]
        S2xyz[i, j, 2] -= reference_z[i]
        Moxyz[i, j, 2] -= reference_z[i]

# Number of coordinate pairs per row
pair_count = m // 2

# Initialize arrays to hold derived coordinate sets
S1xyzA, S1xyzB, S1xyzC, S1xyzD = [], [], [], []
S2xyzA, S2xyzB, S2xyzC, S2xyzD = [], [], [], []

for i in range(n):
    A1, B1, C1, D1 = [], [], [], []
    A2, B2, C2, D2 = [], [], [], []

    for p in range(pair_count):
        odd_idx = 2 * p
        even_idx = 2 * p + 1

        # S1xyz arrays
        B1.append(S1xyz[i, odd_idx])
        C1.append(S1xyz[i, even_idx])

        up1 = S1xyz[i, even_idx].copy()
        up1[1] += 2 * dy
        A1.append(up1)

        if p > 0:
            down1 = S1xyz[i, even_idx].copy()
            down1[1] -= 2 * dy
            D1.append(down1)

        # S2xyz arrays
        B2.append(S2xyz[i, odd_idx])
        C2.append(S2xyz[i, even_idx])

        up2 = S2xyz[i, even_idx].copy()
        up2[1] += 2 * dy
        A2.append(up2)

        if p > 0:
            down2 = S2xyz[i, even_idx].copy()
            down2[1] -= 2 * dy
            D2.append(down2)

    S1xyzA.append(A1)
    S1xyzB.append(B1)
    S1xyzC.append(C1)
    S1xyzD.append(D1)

    S2xyzA.append(A2)
    S2xyzB.append(B2)
    S2xyzC.append(C2)
    S2xyzD.append(D2)

# Convert lists to NumPy arrays
S1xyzA = np.array(S1xyzA)
S1xyzB = np.array(S1xyzB)
S1xyzC = np.array(S1xyzC)
S1xyzD = np.array(S1xyzD)

print(S1xyzA.shape, S1xyzB.shape, S1xyzC.shape, S1xyzD.shape)
S2xyzA = np.array(S2xyzA)
S2xyzB = np.array(S2xyzB)
S2xyzC = np.array(S2xyzC)
S2xyzD = np.array(S2xyzD)

#print(S2xyzA)
# Create MoxyzA by dropping the last point in each row
MoxyzA = Moxyz[:, :m-1, :]

# Output dimensions to verify correctness
print("Original Moxyz shape:", Moxyz.shape)
print("S1xyzA shape:", S1xyzA.shape)
print("MoxyzA shape:", MoxyzA.shape)
print("\nFirst few points of S1xyzA[0]:")
print(S1xyzA[0][:3])
print("\nFirst few points of MoxyzA[0]:")
print(MoxyzA[0][:3])

import matplotlib.pyplot as plt

# ---------------- Raw ----------------
fig, axs = plt.subplots(1, 3, figsize=(15, 4))
titles = ["S1xyz – raw", "S2xyz – raw", "Moxyz – raw"]
for ax, title in zip(axs, titles):
    ax.set_title(title)
    ax.set_xlabel("x")
    ax.set_ylabel("z")
    ax.grid(True)

for i in range(n):
    axs[0].plot(S1xyz[i, :, 0], S1xyz[i, :, 2], label=f"Row {i}")
    axs[1].plot(S2xyz[i, :, 0], S2xyz[i, :, 2])
    axs[2].plot(Moxyz[i, :, 0], Moxyz[i, :, 2])

axs[0].legend(ncol=2, fontsize="small")
plt.tight_layout()
plt.show()

# ---------------- shift ----------------
fig, axs = plt.subplots(1, 3, figsize=(15, 4))
titles = ["S1xyzA – shift", "S2xyzA – shift", "MoxyzA – shift"]
for ax, title in zip(axs, titles):
    ax.set_title(title)
    ax.set_xlabel("x")
    ax.set_ylabel("z")
    ax.grid(True)

for i in range(n):
    axs[0].plot(S1xyz[i, :, 0], S1xyz[i, :, 2], label=f"Row {i}")
    axs[1].plot(S2xyz[i, :, 0], S2xyz[i, :, 2])
    axs[2].plot(Moxyz[i, :, 0], Moxyz[i, :, 2])

axs[0].legend(ncol=2, fontsize="small")
plt.tight_layout()
plt.show()

import numpy as np

# Initial matrices
qS1Initial = np.array([
    [-522544, -523651, -520949, -520637, -522542, -523655, -520964, -520655, -522597, -523688, -520969, -520416, -522593, -523692, -520969, -520389],
    [-535760, -529765, -524777, -532553, -534588, -529843, -527591, -534078, -521154, -527021, -527746, -529786, -527041, -534578, -532445, -528295],
    [-534188, -535751, -535895, -531013, -526685, -525808, -536719, -525793, -533057, -534239, -522763, -526705, -518752, -520244, -532829, -532401],
    [-527044, -526385, -533532, -526181, -531904, -528768, -533280, -526492, -533497, -522246, -520748, -508666, -523508, -523212, -524161, -535505],
    [-528581, -526945, -525386, -526624, -522449, -523325, -532191, -516068, -535449, -530028, -530073, -531603, -538582, -510122, -524716, -527781],
    [-525060, -532855, -523547, -527019, -523440, -525758, -528030, -527600, -536891, -523993, -511641, -521927, -531255, -524286, -515238, -529459],
    [-531357, -521426, -522480, -526126, -531630, -523052, -524450, -528509, -535387, -524531, -528604, -526269, -535666, -534962, -530852, -530594],
    [-524515, -523423, -523909, -526679, -522837, -523209, -529245, -529010, -536937, -515279, -525908, -524019, -526648, -536641, -519919, -514850],
    [-516032, -522910, -519697, -521873, -524248, -530086, -529359, -536413, -536610, -521560, -527808, -522884, -523904, -528811, -522582, -526522],
    [-528134, -520641, -525137, -518446, -520563, -524190, -531472, -527289, -533570, -530200, -527641, -525134, -531113, -525655, -522053, -513183],
    [-514840, -520883, -519120, -527346, -525839, -525683, -532895, -534946, -535563, -528537, -528479, -520872, -529022, -523174, -526159, -516638]
]) * 10**-6

print(qS1Initial)

qS2Initial = np.array([
    [-530683, -534814, -533314, -532729, -530690, -534802, -533297, -532691, -530999, -534786, -533345, -532630, -530995, -534785, -533296, -532712],
    [-528883, -526080, -521014, -527052, -529679, -537984, -531558, -530712, -523480, -534058, -532504, -526017, -523422, -532308, -519635, -525289],
    [-532471, -530983, -520890, -528098, -524626, -519986, -533414, -533902, -529335, -535599, -541374, -528246, -527187, -529924, -532446, -526240],
    [-532771, -517509, -535881, -537880, -531766, -521996, -533038, -534627, -530646, -531358, -528409, -537111, -527062, -526529, -530576, -522421],
    [-528673, -527657, -521474, -521930, -533359, -518885, -525334, -534720, -531029, -525851, -522089, -524837, -519421, -524532, -527762, -520402],
    [-525601, -530528, -532134, -517513, -521847, -515357, -540012, -530133, -526701, -527064, -527107, -525808, -527698, -524474, -525012, -535483],
    [-536615, -523982, -519407, -516326, -522775, -525174, -513068, -519223, -527218, -530021, -526591, -528773, -523496, -524370, -526328, -525965],
    [-528172, -524825, -520772, -533553, -527308, -517928, -515129, -525383, -521766, -529902, -519710, -520907, -523837, -526499, -530152, -530541],
    [-536712, -518284, -530732, -530089, -521104, -528016, -526485, -531562, -521282, -518462, -526418, -523937, -523539, -526580, -532242, -529042],
    [-527743, -525476, -530327, -526100, -530646, -530325, -516390, -523541, -522215, -518142, -523903, -525984, -523990, -527532, -529713, -534108],
    [-534139, -525914, -539110, -527449, -521230, -526765, -513030, -515301, -515985, -522963, -518097, -524978, -527469, -524790, -531773, -538815]
]) * 10**-6

qMoInitial = np.array([
    [1100423, 1099069, 1092979, 1100913, 1100425, 1099079, 1092980, 1100916, 1100762, 1099071, 1092987, 1100686, 1100765, 1099063, 1092980, 1100684],
    [1100491, 1097556, 1096325, 1107065, 1108164, 1108223, 1101119, 1099376, 1097266, 1099890, 1098771, 1100661, 1102942, 1102872, 1091127, 1108442],
    [1112025, 1106724, 1100500, 1093520, 1096362, 1097095, 1105882, 1112650, 1108908, 1110691, 1103353, 1092180, 1092793, 1095843, 1104067, 1109641],
    [1100504, 1093081, 1110859, 1109709, 1102557, 1099354, 1106949, 1106800, 1106987, 1088074, 1096446, 1090409, 1090589, 1100285, 1093925, 1101767],
    [1099534, 1101276, 1089844, 1091288, 1098698, 1092753, 1091362, 1106281, 1098505, 1102615, 1091945, 1103605, 1093751, 1085710, 1097088, 1088728],
    [1102819, 1094557, 1100221, 1093143, 1084868, 1089828, 1110045, 1105190, 1102849, 1094904, 1079012, 1092202, 1100983, 1090751, 1095703, 1097983],
    [1100517, 1088714, 1084852, 1086437, 1097864, 1089883, 1083419, 1096283, 1105401, 1096999, 1095453, 1099887, 1104908, 1099971, 1100826, 1108716],
    [1096311, 1090208, 1096728, 1097594, 1087041, 1089130, 1087433, 1100708, 1101121, 1082653, 1090901, 1084715, 1101821, 1104604, 1093219, 1087031],
    [1096447, 1086857, 1088635, 1093208, 1098414, 1089821, 1112510, 1105954, 1096769, 1091073, 1085747, 1089187, 1101616, 1088828, 1104634, 1097602],
    [1093145, 1091006, 1094746, 1088999, 1095322, 1097394, 1090096, 1099228, 1094688, 1093735, 1095718, 1095402, 1101117, 1086398, 1102698, 1093506],
    [1096868, 1093030, 1096261, 1091174, 1096167, 1098223, 1087247, 1092087, 1101779, 1086541, 1088026, 1097427, 1094194, 1088678, 1113151, 1088001]
]) * 10**-6

# Define n (number of rows) and m (assuming m=1 based on typical use cases if not defined)
#n = qS1Initial.shape[0]  # Number of rows
#m = 1  # Assuming m=1; adjust if you have a different value for m

# Calculate dq
dq = (np.sum(qS1Initial, axis=1) + np.sum(qS2Initial, axis=1) + np.sum(qMoInitial, axis=1)) / (3 * m)

# Define a Python function to replicate the Mathematica anonymous function's logic
#def round_and_adjust(arr, y):
#    # This replicates Round[x + 10.^(y - 1), 10.^y]
#    # In Mathematica, Round[x, step] rounds x to the nearest multiple of step.
#    # The expression `Round[val + 10.^(y - 1), 10.^y]` suggests a specific rounding behavior.
#    # It essentially adds 0.0001 (for y=-4) before rounding to the specified precision.
#    # We will round to the nearest multiple of 10^y.
#
#    step = 10**y
#    return np.round((arr + 10**(y - 1)) / step) * step


# Alternative one-liner version with broadcasting:
def process_compact(x, y=-4):
    dq_broadcast = dq[:, np.newaxis] if x.ndim == 2 and dq.ndim == 1 else dq
    precision = 10**y
    return np.round((x - dq_broadcast + 10**(y-1)) / precision) * precision

S1q = process_compact(qS1Initial)
S2q = process_compact(qS2Initial)
Moq = process_compact(qMoInitial)

# Apply the function to each initial quantity
#S1q = round_and_adjust(qS1Initial, -4)
#S2q = round_and_adjust(qS2Initial, -4)
#Moq = round_and_adjust(qMoInitial, -4)

# Print the results to verify (optional)
print("dq:\n", dq)
print("\nS1q:\n", S1q)
print("\nS2q:\n", S2q)
print("\nMoq:\n", Moq)

import numpy as np

# Initial matrices (converted from Mathematica lists to NumPy arrays)
S1qq = np.array([
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5375, -0.5378, -0.5386, -0.5398, -0.5415, -0.543, -0.5442, -0.5452, -0.5456, -0.5453, -0.5444, -0.5432, -0.5416, -0.54, -0.5388, -0.5378],
    [-0.5376, -0.538, -0.5388, -0.54, -0.5415, -0.543, -0.5442, -0.5451, -0.5454, -0.5452, -0.5442, -0.5431, -0.5416, -0.54, -0.5389, -0.538],
    [-0.537, -0.537, -0.5376, -0.539, -0.5406, -0.5425, -0.544, -0.5454, -0.546, -0.546, -0.5454, -0.5442, -0.5425, -0.5406, -0.539, -0.5376],
    [-0.532164, -0.532761, -0.534461, -0.537005, -0.540006, -0.543007, -0.545551, -0.547251, -0.547848, -0.547251, -0.545551, -0.543007, -0.540006, -0.537005, -0.534461, -0.532761]
])

S2qq = np.array([
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415, -0.5415],
    [-0.5455, -0.5452, -0.5444, -0.5432, -0.5415, -0.54, -0.5388, -0.5378, -0.5374, -0.5377, -0.5386, -0.5398, -0.5414, -0.543, -0.5442, -0.5452],
    [-0.5454, -0.545, -0.5442, -0.543, -0.5415, -0.54, -0.5388, -0.5379, -0.5376, -0.5378, -0.5388, -0.5399, -0.5414, -0.543, -0.5441, -0.545],
    [-0.546, -0.546, -0.5454, -0.544, -0.5424, -0.5405, -0.539, -0.5376, -0.537, -0.537, -0.5376, -0.5388, -0.5405, -0.5424, -0.544, -0.5454],
    [-0.547723, -0.547126, -0.545426, -0.542882, -0.539881, -0.53688, -0.534336, -0.532636, -0.532039, -0.532636, -0.534336, -0.53688, -0.539881, -0.542882, -0.545426, -0.547126]
])

Moqq = np.array([
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083],
    [1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083, 1.083]
])

# Define the Ave function
def Ave(x, n=1):
    """
    Calculates the average of a list or NumPy array, optionally divided by n.
    """

    return np.sum(x) / len(x) / n

# Define the Fur function
def Fur(ff, n=3):
    """
    Performs a Fourier transform, zeros out components except for the 'n' largest
    absolute magnitudes (up to 6), and then performs an inverse Fourier transform.
    """
    ftd = np.fft.fft(ff).real

    # Get the indices that would sort Abs[ftd] in ascending order
    sorted_indices = np.argsort(np.abs(ftd))

    # Get the indices of the 'n' largest (or up to 6) absolute values
    num_indices_to_keep = min(n, 6)
    a = sorted_indices[-num_indices_to_keep:]

    # Sort 'a' to ensure the slicing logic works correctly (ascending order of indices)
    a = np.sort(a)

    # Initialize ftd for modification
    modified_ftd = np.copy(ftd)

    if len(a) > 0:
        modified_ftd[0:a[0]] = 0

        for i in range(len(a) - 1):
            modified_ftd[a[i] + 1 : a[i+1]] = 0

        modified_ftd[a[-1] + 1:] = 0

    yy = np.fft.ifft(modified_ftd).real

    return yy

# Example usage (assuming S1q, S2q, m are defined as in the previous output)
# For demonstration, let's use the last rows of S1qq and S2qq for S1q[11] and S2q[11] respectively.
# In a real scenario, S1q and S2q would come from the previous calculation.
S1q_row_11 = S1qq[-1, :]
S2q_row_11 = S2qq[-1, :]
m = 1

term_inside_total = (S1q_row_11 + S2q_row_11) / 2
total_term = 2 * Ave(term_inside_total, m)

expression_for_fur = (-S1q_row_11 + total_term + S2q_row_11) / 2

# Apply Fur function
result_fur = Fur(expression_for_fur)

# Second expression: This assumes '%' refers to the previous output (result_fur)
second_expression_result = -result_fur + total_term

#print("S1qq:\n", S1qq)
#print("\nS2qq:\n", S2qq)
#print("\nMoqq:\n", Moqq)
#print("\nResult of Fur function on expression_for_fur:\n", result_fur)
#print("\nResult of the second expression:\n", second_expression_result)

# number of corrugation
CorrI = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
CorrR = [0.0, 0.97, 1.93, 2.9, 3.88, 4.86, 5.83, 6.81, 7.78, 8.76, 9.75]

xbox = [43.647709, 43.636913, 43.604687, 43.551128, 43.476566,
        43.381317, 43.265907, 43.130848, 42.976864, 42.804615, 42.614906]
xbox = [x / 10 for x in xbox] # Applying the division by 10

# In Mathematica, Table[expr, n] creates a list with 'n' copies of expr.
ybox = [3.150002 / 10] * n
zbox = [28.150002 / 10] * n

# ColorV conversion: RGBColor[r, g, b] in Mathematica corresponds to (r, g, b) tuples in Python
ColorV = [
    (0.0, 0.0, 0.0),
    (0.58, 0.23, 0.027450980392156862),
    (0.996078431372549, 0.3607843137254902, 0.027450980392156862),
    (0.996078431372549, 0.72, 0.03529411764705882),
    (0.5411764705882353, 0.76, 0.027450980392156862),
    (0.1450980392156863, 0.43529411764705883, 0.02),
    (0.00784313725490196, 0.5098039215686274, 0.9294117647058824),
    (0.15294117647058825, 0.11372549019607843, 0.49019607843137253),
    (0.55, 0.2627450980392157, 0.65),
    (0.8901960784313725, 0.13, 0.59),
    (0.87, 0.027450980392156862, 0.0)
]
# model_fit.py
# ------------------------------------------------------------------
# Translation of the supplied Mathematica code to Python
# (c) 2025 – generated by ChatGPT‐o3
# ------------------------------------------------------------------


import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit, least_squares
import sympy as sp

# --- Global variables and placeholder data (from previous conversions and assumptions) ---
# These are placeholders and should be replaced with actual data if available.
S1qq = [[-0.5]]
Moqq = [[1.0]]

# ------------------------------------------------------------------
# 1. CONSTANTS AND RAW ARRAYS
# ------------------------------------------------------------------
# !! Replace the next four lines with your real data (lists or np.ndarrays)


# ------------------------------------------------------------------
QS  = -0.5
QMo =  1.0

# Overwrite with first element of the imported tables (note 0‑based indexing)
QS  = S1qq[0][0]
QMo = Moqq[0][0]

n   = len(MoxyzA)                         # number of chains / frames


mMo: float = 95.95   # Mo atomic mass
mS:  float = 32.065  # S  atomic mass
m:   int   = 16      # unit‑cell parameter (unchanged)

# Material and system properties
mMo = 95.95
mS = 32.065
m = 16 # Assumed from loop bounds like m/2
n = 11 # Inferred from the length of the lists

import numpy as np
import sympy as sp
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from dataclasses import dataclass
from typing import List, Tuple, Dict, Optional, Callable
import warnings
from pathlib import Path

# Suppress optimization warnings for cleaner output
warnings.filterwarnings('ignore', category=RuntimeWarning)

@dataclass
class MaterialProperties:
    """Container for material properties and system parameters."""
    mMo: float = 95.95  # Molybdenum atomic mass
    mS: float = 32.065  # Sulfur atomic mass
    QS: float = -0.5    # Sulfur charge
    QMo: float = 1.0    # Molybdenum charge
    m: int = 16         # System parameter
    n: int = 11         # Number of configurations

@dataclass
class WaveVectorData:
    """Container for wave vector calculations and components."""
    kz_part1: np.ndarray
    kz_part2: np.ndarray
    kz_part3: np.ndarray
    kz_part4: np.ndarray
    kk: np.ndarray

    @property
    def kz_calc(self) -> np.ndarray:
        """Calculate combined kz values."""
        return (self.kz_part1 + self.kz_part2 +
                self.kz_part3 / 2 + self.kz_part4 / 2) / 4

    @property
    def kz(self) -> np.ndarray:
        """Get kz values (alias for kk)."""
        return self.kk

    @property
    def kx(self) -> np.ndarray:
        """Get kx values (2 * kk)."""
        return 2 * self.kk

class DataGenerator:
    """Handles generation of placeholder data and data loading."""

    def __init__(self, props: MaterialProperties, seed: int = 42):
        self.props = props
        self.rng = np.random.default_rng(seed)

#`    def generate_placeholder_data(self) -> Dict[str, np.ndarray]:
#`        """Generate placeholder random data with proper shapes."""
#`        n, m = self.props.n, self.props.m
#`
#`        return {
#`            'MoxyzA': self.rng.random((n, m, 3)),
#`            'S1xyzA': self.rng.random((n, m // 2, 3)),
#`            'S2xyzA': self.rng.random((n, m // 2, 3)),
#`            'S1xyzB': self.rng.random((n, m // 2 + 1, 3)),
#`            'S2xyzB': self.rng.random((n, m // 2 + 1, 3)),
#`            'S1xyzC': self.rng.random((n, m // 2, 3)),
#`            'S2xyzC': self.rng.random((n, m // 2, 3)),
#`            'S1xyzD': self.rng.random((n, m // 2, 3)),
#`            'S2xyzD': self.rng.random((n, m // 2, 3))
#`        }

class PhysicsCalculator:
    """Handles physics calculations for dipole moments and center of mass."""

    def __init__(self, props: MaterialProperties):
        self.props = props

    def calculate_dipole_moments(self, data: Dict[str, np.ndarray]) -> Tuple[np.ndarray, np.ndarray]:
        """Calculate dipole moments pA and pB."""
        n, m = self.props.n, self.props.m
        QMo, QS = self.props.QMo, self.props.QS

        # Extract data arrays
        MoxyzA = data['MoxyzA']
        S1xyzA, S2xyzA = data['S1xyzA'], data['S2xyzA']
        S1xyzB, S2xyzB = data['S1xyzB'], data['S2xyzB']
        S1xyzC, S2xyzC = data['S1xyzC'], data['S2xyzC']
        S1xyzD, S2xyzD = data['S1xyzD'], data['S2xyzD']

        # Calculate pA
        pA = np.array([
            [
                MoxyzA[j, i*2] * QMo + (
                    S1xyzA[j, i] + S2xyzA[j, i] + S1xyzB[j, i] +
                    S2xyzB[j, i] + S1xyzC[j, i] + S2xyzC[j, i]
                ) * QS / 3
                for i in range(m // 2)
            ]
            for j in range(n)
        ])

        # Calculate pB
        pB = np.array([
            [
                MoxyzA[j, i*2 + 1] * QMo + (
                    S1xyzB[j, i+1] + S2xyzB[j, i+1] + S1xyzC[j, i] +
                    S2xyzC[j, i] + S1xyzD[j, i] + S2xyzD[j, i]
                ) * QS / 3
                for i in range(m // 2 - 1)
            ]
            for j in range(n)
        ])

        return np.round(pA, 6), np.round(pB, 6)

    def calculate_center_of_mass(self, data: Dict[str, np.ndarray]) -> Tuple[np.ndarray, np.ndarray]:
        """Calculate center of mass rA and rB."""
        n, m = self.props.n, self.props.m
        mMo, mS = self.props.mMo, self.props.mS

        # Extract data arrays
        MoxyzA = data['MoxyzA']
        S1xyzA, S2xyzA = data['S1xyzA'], data['S2xyzA']
        S1xyzB, S2xyzB = data['S1xyzB'], data['S2xyzB']
        S1xyzC, S2xyzC = data['S1xyzC'], data['S2xyzC']
        S1xyzD, S2xyzD = data['S1xyzD'], data['S2xyzD']

        # Calculate rA
        rA = np.array([
            [
                (MoxyzA[j, i*2] * mMo + (
                    S1xyzA[j, i] + S2xyzA[j, i] + S1xyzB[j, i] +
                    S2xyzB[j, i] + S1xyzC[j, i] + S2xyzC[j, i]
                ) * mS) / (mMo + 6 * mS)
                for i in range(m // 2)
            ]
            for j in range(n)
        ])

        # Calculate rB
        rB = np.array([
            [
                (MoxyzA[j, i*2 + 1] * mMo + (
                    S1xyzB[j, i+1] + S1xyzC[j, i] + S2xyzC[j, i+1] +
                    S1xyzD[j, i] + S2xyzD[j, i]
                ) * mS) / (mMo + 6 * mS)
                for i in range(m // 2 - 1)
            ]
            for j in range(n)
        ])

        return rA, rB

    @staticmethod
    def combine_arrays(arrayA: np.ndarray, arrayB: np.ndarray, n: int, m: int) -> np.ndarray:
        """Combine pA/pB or rA/rB arrays into a single array."""
        combined_list = []
        for i in range(n):
            temp = []
            for j in range(m // 2 - 1):
                temp.extend([arrayA[i, j], arrayB[i, j]])
            temp.append(arrayA[i, -1])
            combined_list.append(temp)
        return np.array(combined_list)

class FittingFunctions:
    """Collection of fitting functions used in the analysis."""

    @staticmethod
    def f1(x: np.ndarray, a: float) -> np.ndarray:
        """Cosine function: a * cos(kz * x)"""
        return a * np.cos(FittingFunctions._kz * x)

    @staticmethod
    def f2(x: np.ndarray, a: float, b: float) -> np.ndarray:
        """Linear + sine function: a * x + b * sin(kx * x)"""
        return a * x + b * np.sin(FittingFunctions._kx * x)

    @staticmethod
    def f3(x: np.ndarray, a: float, b: float) -> np.ndarray:
        """Sine + cosine function: a * sin(kz * x) + b * cos(kz * x)"""
        return a * np.sin(FittingFunctions._kz * x) + b * np.cos(FittingFunctions._kz * x)

    @staticmethod
    def f4(x: np.ndarray, a: float, b: float, c: float) -> np.ndarray:
        """Sine + cosine + constant: a * sin(kx * x) + b * cos(kx * x) + c"""
        return a * np.sin(FittingFunctions._kx * x) + b * np.cos(FittingFunctions._kx * x) + c

    # Class variables to store current k values
    _kz = 1.0
    _kx = 2.0

    @classmethod
    def set_k_values(cls, kz: float, kx: float):
        """Set the current k values for fitting functions."""
        cls._kz = kz
        cls._kx = kx

class NonlinearFitter:
    """Handles nonlinear curve fitting operations."""

    def __init__(self, wave_data: WaveVectorData):
        self.wave_data = wave_data
        self.functions = FittingFunctions()

    @staticmethod
    def r_squared(y_true: np.ndarray, y_pred: np.ndarray) -> float:
        """Calculate R-squared value."""
        ss_res = np.sum((y_true - y_pred) ** 2)
        ss_tot = np.sum((y_true - np.mean(y_true)) ** 2)
        return 1 - (ss_res / ss_tot) if ss_tot != 0 else 0

    def fit_data(self, x_data: np.ndarray, y_data: np.ndarray,
                 func: Callable, initial_params: List[float],
                 use_kx: bool = False) -> Tuple[List[np.ndarray], List[float]]:
        """Generic fitting function for all data types."""
        n = len(x_data)
        params_list = []
        r2_list = []

        for i in range(n):
            # Set appropriate k values
            kz = self.wave_data.kk[i]
            kx = 2 * kz if use_kx else kz
            self.functions.set_k_values(kz, kx)

            try:
                popt, _ = curve_fit(func, x_data[i], y_data[i], p0=initial_params)
                params_list.append(popt)

                y_pred = func(x_data[i], *popt)
                r2_list.append(self.r_squared(y_data[i], y_pred))
            except Exception as e:
                print(f"Fitting failed for index {i}: {e}")
                params_list.append(np.array(initial_params))
                r2_list.append(0.0)

        return params_list, r2_list

class SymbolicCalculator:
    """Handles symbolic mathematics calculations."""

    def __init__(self):
        self.symbols = self._define_symbols()
        self.equations = self._define_equations()

    def _define_symbols(self) -> Dict[str, sp.Symbol]:
        """Define all symbolic variables."""
        symbol_names = [
            'x', 'z', 'U0', 'V0', 'W0', 'cU', 'dzs', 'dzc',
            'dxs', 'dxc', 'cd', 'gd', 'k', 'kz', 'kx',
            'e_zzx', 'f_zxzx', 'e_xxx', 'f_xxxx'
        ]
        return {name: sp.Symbol(name) for name in symbol_names}

    def _define_equations(self) -> Dict[str, sp.Eq]:
        """Define symbolic equations."""
        s = self.symbols

        # Define symbolic functions
        fUz_sym = s['U0'] * sp.cos(s['k'] * s['x'])
        fUx_sym = s['V0'] * s['x'] + s['W0'] * sp.sin(2 * s['k'] * s['x']) + s['cU']

        # Define equations
        equzf_lhs = s['dzs'] * sp.sin(s['k'] * s['x']) + s['dzc'] * sp.cos(s['k'] * s['x'])
        equzf_rhs = s['e_zzx'] * sp.diff(fUz_sym, s['x']) / 2 + s['f_zxzx'] * sp.diff(fUz_sym, s['x'], 2) / 2

        equxf_lhs = s['dxs'] * sp.sin(2*s['k']*s['x']) + s['dxc'] * sp.cos(2*s['k']*s['x']) + s['cd']
        equxf_rhs = s['e_xxx'] * sp.diff(fUx_sym, s['x']) + s['f_xxxx'] * sp.diff(fUx_sym, s['x'], 2)

        return {
            'equzf': sp.Eq(equzf_lhs, equzf_rhs),
            'equxf': sp.Eq(equxf_lhs, equxf_rhs)
        }

    def solve_coefficients(self) -> Dict[str, sp.Expr]:
        """Solve for the symbolic coefficients."""
        s = self.symbols
        eq = self.equations

        try:
            f3131 = sp.solve(eq['equzf'].subs({s['dzs']: 0, s['e_zzx']: 0}), s['f_zxzx'])[0]
        except (IndexError, TypeError):
            f3131 = 0

        try:
            e331 = sp.solve(eq['equzf'].subs({s['dzc']: 0, s['f_zxzx']: 0}), s['e_zzx'])[0]
        except (IndexError, TypeError):
            e331 = 0

        try:
            f1111 = sp.solve(eq['equxf'].subs({s['dxc']: 0, s['e_xxx']: 0, s['cd']: 0}), s['f_xxxx'])[0]
        except (IndexError, TypeError):
            f1111 = 0

        try:
            e111_sol = sp.solve(eq['equxf'].subs({s['dxs']: 0, s['f_xxxx']: 0, s['cd']: 0, s['V0']: 0}), s['e_xxx'])
            e111 = e111_sol[0] if e111_sol else 0
        except (IndexError, TypeError):
            e111 = 0

        return {'f3131': f3131, 'e331': e331, 'f1111': f1111, 'e111': e111}

class Visualizer:
    """Handles all plotting and visualization tasks."""

    def __init__(self, wave_data: WaveVectorData):
        self.wave_data = wave_data
        plt.style.use('default')  # Ensure consistent plotting style

    def plot_wave_vector(self):
        """Plot the wave vector kk."""
        plt.figure(figsize=(10, 6))
        plt.plot(self.wave_data.kk, marker='o', linestyle='-', linewidth=2, markersize=6)
        plt.title("Wave Vector kk", fontsize=14, fontweight='bold')
        plt.xlabel("Index", fontsize=12)
        plt.ylabel("kk Value", fontsize=12)
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

    def plot_fits(self, x_data: np.ndarray, y_data: np.ndarray,
                  fit_func: Callable, params_list: List[np.ndarray],
                  title: str, num_to_plot: Optional[int] = None):
        """Plot raw data and fitted functions."""
        if num_to_plot is None:
            num_to_plot = len(x_data)

        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        axes = axes.flatten()

        for i in range(min(6, num_to_plot)):
            ax = axes[i]

            # Set k values for the fitting function
            kz = self.wave_data.kk[i]
            kx = 2 * kz
            FittingFunctions.set_k_values(kz, kx)

            # Plot data points
            ax.scatter(x_data[i], y_data[i], alpha=0.7, s=30, label='Data')

            # Plot fit
            x_fit = np.linspace(np.min(x_data[i]), np.max(x_data[i]), 200)
            y_fit = fit_func(x_fit, *params_list[i])
            ax.plot(x_fit, y_fit, 'r-', linewidth=2, label='Fit')

            ax.set_title(f'Config {i}', fontweight='bold')
            ax.set_xlabel('rx')
            ax.set_ylabel('Value')
            ax.legend()
            ax.grid(True, alpha=0.3)

        # Hide unused subplots
        for i in range(min(6, num_to_plot), 6):
            axes[i].set_visible(False)

        fig.suptitle(title, fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.show()

    def plot_symbolic_functions(self, expr: sp.Expr, params_dict: Dict[str, np.ndarray],
                               x_data: np.ndarray, title: str):
        """Plot functions derived from symbolic expressions."""
        plt.figure(figsize=(12, 6))

        # Get parameter names and values
        param_names = list(params_dict.keys())
        num_plots = len(params_dict[param_names[0]])

        x_sym = sp.Symbol('x')
        k_sym = sp.Symbol('k')

        for i in range(min(num_plots, 10)):  # Limit to 10 plots for clarity
            # Create substitution dictionary
            subs_dict = {sp.Symbol(name): values[i] for name, values in params_dict.items()}
            subs_dict[k_sym] = self.wave_data.kk[i + 1]  # Skip first element

            # Lambdify and evaluate
            try:
                func = sp.lambdify(x_sym, expr.subs(subs_dict), 'numpy')
                x_vals = np.linspace(np.min(x_data[i + 1]), np.max(x_data[i + 1]), 200)
                y_vals = func(x_vals)
                plt.plot(x_vals, y_vals, label=f'Config {i + 1}', linewidth=2)
            except Exception as e:
                print(f"Failed to plot function {i}: {e}")

        plt.title(title, fontsize=14, fontweight='bold')
        plt.xlabel('x', fontsize=12)
        plt.ylabel('Value', fontsize=12)
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def main():
    """Main analysis pipeline."""
    print("=== Materials Science Analysis Pipeline ===\n")

    # Initialize components
    props = MaterialProperties()
    wave_data = WaveVectorData(
        kz_part1=np.array([1.42, 1.43991, 1.44131, 1.44331, 1.44583, 1.44905,
                          1.45278, 1.45746, 1.46252, 1.46845, 1.47493]),
        kz_part2=np.array([1.42, 1.38701, 1.39382, 1.40107, 1.38963, 1.40031,
                          1.40402, 1.40898, 1.41303, 1.41571, 1.42015]),
        kz_part3=np.array([2.88, 2.74776, 2.75575, 2.76886, 2.87345, 2.88373,
                          2.89378, 2.90506, 2.91678, 2.92931, 2.94311]),
        kz_part4=np.array([2.88198, 2.8941, 2.81159, 2.85215, 2.69466, 2.77528,
                          2.84068, 2.87852, 2.87045, 2.85481, 2.87056]),
        kk=np.array([1.4399, 1.43991, 1.44131, 1.44331, 1.44583, 1.44905,
                    1.45278, 1.45746, 1.46252, 1.46845, 1.47493])
    )

    data_gen = DataGenerator(props)
    physics_calc = PhysicsCalculator(props)
    fitter = NonlinearFitter(wave_data)
    symbolic_calc = SymbolicCalculator()
    visualizer = Visualizer(wave_data)

    print("1. Generating placeholder data...")
    data = {
    'MoxyzA': MoxyzA,
    'S1xyzA': S1xyzA,
    'S2xyzA': S2xyzA,
    'S1xyzB': S1xyzB,
    'S2xyzB': S2xyzB,
    'S1xyzC': S1xyzC,
    'S2xyzC': S2xyzC,
    'S1xyzD': S1xyzD,
    'S2xyzD': S2xyzD
    }   
    #data = data_gen.generate_placeholder_data()

    print("2. Calculating dipole moments and center of mass...")
    pA, pB = physics_calc.calculate_dipole_moments(data)
    rA, rB = physics_calc.calculate_center_of_mass(data)

    # Combine arrays
    p = physics_calc.combine_arrays(pA, pB, props.n, props.m)
    r = physics_calc.combine_arrays(rA, rB, props.n, props.m)

    # Extract components
    px, py, pz = p.transpose(2, 0, 1)
    rx, ry, rz = r.transpose(2, 0, 1)

    # Calculate displacement
    U = np.array([r[i] - r[0] for i in range(props.n)])
    Ux, Uy, Uz = U.transpose(2, 0, 1)

    print("3. Performing nonlinear fits...")
    # Fit all data
    fit_results = {}

    # Uz fitting
    params_Uz, r2_Uz = fitter.fit_data(rx, Uz, FittingFunctions.f1, [1.8])
    fit_results['Uz'] = {'params': params_Uz, 'r2': r2_Uz}

    # Ux fitting
    params_Ux, r2_Ux = fitter.fit_data(rx, Ux, FittingFunctions.f2, [-0.1, 3.6], use_kx=True)
    fit_results['Ux'] = {'params': params_Ux, 'r2': r2_Ux}

    # pz fitting
    params_pz, r2_pz = fitter.fit_data(rx, pz, FittingFunctions.f3, [1.8/30, 0])
    fit_results['pz'] = {'params': params_pz, 'r2': r2_pz}

    # px fitting
    initial_px = [fit_results['Ux']['params'][i][1] * 0.012 for i in range(props.n)]
    params_px, r2_px = fitter.fit_data(rx, px, FittingFunctions.f4,
                                      [np.mean(initial_px), 0.0002, 0.001], use_kx=True)
    fit_results['px'] = {'params': params_px, 'r2': r2_px}

    # Print R-squared values
    print("\n4. Fit Quality (R-squared values):")
    for name, results in fit_results.items():
        print(f"R² for {name}: {np.array(results['r2'])[1:]}")

    print("\n5. Solving symbolic equations...")
    coefficients = symbolic_calc.solve_coefficients()
    print(f"Symbolic coefficients: {coefficients}")

    print("\n6. Computing final parameters...")
    # Extract parameters (skip first element as in original)
    U0_vals = np.array([p[0] for p in params_Uz])[1:]
    V0_vals = np.array([p[0] for p in params_Ux])[1:]
    W0_vals = np.array([p[1] for p in params_Ux])[1:]
    dzs_vals = np.array([p[0] for p in params_pz])[1:]
    dzc_vals = np.array([p[1] for p in params_pz])[1:]
    dxs_vals = np.array([p[0] for p in params_px])[1:]
    dxc_vals = np.array([p[1] for p in params_px])[1:]
    cd_vals = np.array([p[2] for p in params_px])[1:]
    k_vals = wave_data.kk[1:]

    # Calculate final coefficients
    try:
        f3131_vals = [float(coefficients['f3131'].subs({'U0': u, 'dzc': d, 'k': k}))
                     for u, d, k in zip(U0_vals, dzc_vals, k_vals)]
        e331_vals = [float(coefficients['e331'].subs({'U0': u, 'dzs': d, 'k': k}))
                    for u, d, k in zip(U0_vals, dzs_vals, k_vals)]
        f1111_vals = [float(coefficients['f1111'].subs({'W0': w, 'dxs': d, 'k': k}))
                     for w, d, k in zip(W0_vals, dxs_vals, k_vals)]
        e111_vals = [float(coefficients['e111'].subs({'W0': w, 'dxc': d, 'k': k}))
                    for w, d, k in zip(W0_vals, dxc_vals, k_vals)]

        # Scale results
        print("\nFinal Results:")
        print(f"f3131 (×100): {100 * np.array(f3131_vals)}")
        print(f"e331  (×1000): {1000 * np.array(e331_vals)}")
        print(f"f1111 (×100): {100 * np.array(f1111_vals)}")
        print(f"e111  (×1000): {1000 * np.array(e111_vals)}")

    except Exception as e:
        print(f"Error in final calculations: {e}")

    print("\n7. Generating visualizations...")

    # Plot wave vector
    visualizer.plot_wave_vector()

    # Plot fits
    visualizer.plot_fits(rx, pz, FittingFunctions.f3, params_pz, "pz(x) Fitting Results")
    visualizer.plot_fits(rx, px, FittingFunctions.f4, params_px, "px(x) Fitting Results")
    visualizer.plot_fits(rx, Ux, FittingFunctions.f2, params_Ux, "Ux(x) Fitting Results")
    visualizer.plot_fits(rx, Uz, FittingFunctions.f1, params_Uz, "Uz(x) Fitting Results")

    print("\nAnalysis complete!")

if __name__ == "__main__":
    main()
